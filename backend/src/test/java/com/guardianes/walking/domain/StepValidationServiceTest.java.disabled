package com.guardianes.walking.domain;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import com.guardianes.shared.infrastructure.metrics.BusinessMetricsService;
import com.guardianes.shared.domain.model.GuardianId;
import com.guardianes.shared.domain.model.Timestamp;
import com.guardianes.walking.domain.model.StepCount;
import com.guardianes.walking.domain.model.StepRecord;
import com.guardianes.walking.domain.model.StepValidationResult;
import com.guardianes.walking.domain.repository.StepRepository;
import com.guardianes.walking.domain.service.AnomalyDetectionService;
import com.guardianes.walking.domain.service.StepValidationService;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

@DisplayName("Step Validation Service Tests")
class StepValidationServiceTest {

    @Mock private StepRepository stepRepository;

    @Mock private AnomalyDetectionService anomalyDetectionService;

    @Mock private BusinessMetricsService metricsService;

    private StepValidationService stepValidationService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        stepValidationService =
                new StepValidationService(stepRepository, anomalyDetectionService, metricsService);
    }

    @Test
    @DisplayName("Should validate normal step count")
    void shouldValidateNormalStepCount() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        StepCount stepCount = StepCount.of(5000);
        Timestamp timestamp = Timestamp.of(LocalDateTime.now());

        when(stepRepository.findByGuardianIdAndDate(guardianId, timestamp.value().toLocalDate()))
                .thenReturn(
                        Arrays.asList(StepRecord.createWithTimestamp(guardianId, StepCount.of(2000), timestamp.minusHours(2))));
        when(anomalyDetectionService.isAnomalous(guardianId, stepCount, timestamp))
                .thenReturn(false);

        // When
        StepValidationResult result =
                stepValidationService.validateStepCount(guardianId, stepCount, timestamp);

        // Then
        assertTrue(result.isValid());
        assertNull(result.getErrorMessage());
        verify(stepRepository, times(1))
                .findByGuardianIdAndDate(guardianId, timestamp.value().toLocalDate());
        verify(anomalyDetectionService, times(1)).isAnomalous(guardianId, stepCount, timestamp.value());
    }

    @Test
    @DisplayName("Should reject negative step count")
    void shouldRejectNegativeStepCount() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        StepCount stepCount = StepCount.of(-100);
        Timestamp timestamp = Timestamp.of(LocalDateTime.now());

        // When
        StepValidationResult result =
                stepValidationService.validateStepCount(guardianId, stepCount, timestamp);

        // Then
        assertFalse(result.isValid());
        assertEquals("Step count cannot be negative", result.getErrorMessage());
        verify(stepRepository, never()).findByGuardianIdAndDate(any(GuardianId.class), any(LocalDate.class));
        verify(anomalyDetectionService, never())
                .isAnomalous(any(GuardianId.class), any(StepCount.class), any(LocalDateTime.class));
    }

    @Test
    @DisplayName("Should reject step count exceeding daily maximum")
    void shouldRejectStepCountExceedingDailyMaximum() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        StepCount stepCount = StepCount.of(10000);
        Timestamp timestamp = Timestamp.of(LocalDateTime.now());

        when(stepRepository.findByGuardianIdAndDate(guardianId, timestamp.value().toLocalDate()))
                .thenReturn(
                        Arrays.asList(StepRecord.createWithTimestamp(guardianId, StepCount.of(45000), timestamp.minusHours(1))));

        // When
        StepValidationResult result =
                stepValidationService.validateStepCount(guardianId, stepCount, timestamp);

        // Then
        assertFalse(result.isValid());
        assertEquals(
                "Daily step count would exceed maximum allowed (50000)", result.getErrorMessage());
        verify(stepRepository, times(1))
                .findByGuardianIdAndDate(guardianId, timestamp.value().toLocalDate());
        verify(anomalyDetectionService, never())
                .isAnomalous(any(GuardianId.class), any(StepCount.class), any(LocalDateTime.class));
    }

    @Test
    @DisplayName("Should reject step count that would exceed daily maximum")
    void shouldRejectStepCountThatWouldExceedDailyMaximum() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        StepCount stepCount = StepCount.of(60000);
        Timestamp timestamp = Timestamp.of(LocalDateTime.now());

        // When
        StepValidationResult result =
                stepValidationService.validateStepCount(guardianId, stepCount, timestamp);

        // Then
        assertFalse(result.isValid());
        assertEquals("Step count exceeds daily maximum (50000)", result.getErrorMessage());
        verify(stepRepository, never()).findByGuardianIdAndDate(any(GuardianId.class), any(LocalDate.class));
        verify(anomalyDetectionService, never())
                .isAnomalous(any(GuardianId.class), any(StepCount.class), any(LocalDateTime.class));
    }

    @Test
    @DisplayName("Should reject anomalous step count")
    void shouldRejectAnomalousStepCount() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        StepCount stepCount = StepCount.of(15000);
        Timestamp timestamp = Timestamp.of(LocalDateTime.now());

        when(stepRepository.findByGuardianIdAndDate(guardianId, timestamp.value().toLocalDate()))
                .thenReturn(
                        Arrays.asList(StepRecord.createWithTimestamp(guardianId, StepCount.of(2000), timestamp.minusHours(2))));
        when(anomalyDetectionService.isAnomalous(guardianId, stepCount, timestamp))
                .thenReturn(true);

        // When
        StepValidationResult result =
                stepValidationService.validateStepCount(guardianId, stepCount, timestamp);

        // Then
        assertFalse(result.isValid());
        assertEquals(
                "Step count appears anomalous and requires verification", result.getErrorMessage());
        verify(stepRepository, times(1))
                .findByGuardianIdAndDate(guardianId, timestamp.value().toLocalDate());
        verify(anomalyDetectionService, times(1)).isAnomalous(guardianId, stepCount, timestamp.value());
    }

    @Test
    @DisplayName("Should validate step increment reasonableness")
    void shouldValidateStepIncrementReasonableness() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        StepCount previousSteps = StepCount.of(1000);
        StepCount currentSteps = StepCount.of(2000);
        Timestamp previousTimestamp = Timestamp.of(LocalDateTime.now().minusHours(1));
        Timestamp currentTimestamp = Timestamp.of(LocalDateTime.now());

        // When
        boolean result =
                stepValidationService.isReasonableIncrement(
                        guardianId,
                        previousSteps,
                        currentSteps,
                        previousTimestamp.value(),
                        currentTimestamp.value());

        // Then
        assertTrue(result);
    }

    @Test
    @DisplayName("Should reject unreasonable step increment")
    void shouldRejectUnreasonableStepIncrement() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        StepCount previousSteps = StepCount.of(1000);
        StepCount currentSteps = StepCount.of(20000);
        Timestamp previousTimestamp = Timestamp.of(LocalDateTime.now().minusMinutes(10));
        Timestamp currentTimestamp = Timestamp.of(LocalDateTime.now());

        // When
        boolean result =
                stepValidationService.isReasonableIncrement(
                        guardianId,
                        previousSteps,
                        currentSteps,
                        previousTimestamp.value(),
                        currentTimestamp.value());

        // Then
        assertFalse(result);
    }

    @Test
    @DisplayName("Should detect step count spikes")
    void shouldDetectStepCountSpikes() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        LocalDate date = LocalDate.now();
        List<StepRecord> recentSteps =
                Arrays.asList(
                        StepRecord.createWithTimestamp(guardianId, StepCount.of(1000), Timestamp.of(date.minusDays(2).atTime(10, 0))),
                        StepRecord.createWithTimestamp(guardianId, StepCount.of(1200), Timestamp.of(date.minusDays(1).atTime(10, 0))),
                        StepRecord.createWithTimestamp(guardianId, StepCount.of(15000), Timestamp.of(date.atTime(10, 0))) // Spike
                        );

        when(stepRepository.findByGuardianIdAndDateRange(guardianId, date.minusDays(7), date))
                .thenReturn(recentSteps);

        // When
        boolean result = stepValidationService.hasStepCountSpike(guardianId, date);

        // Then
        assertTrue(result);
        verify(stepRepository, times(1))
                .findByGuardianIdAndDateRange(guardianId, date.minusDays(7), date);
    }

    @Test
    @DisplayName("Should not detect spike in normal step progression")
    void shouldNotDetectSpikeInNormalStepProgression() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        LocalDate date = LocalDate.now();
        List<StepRecord> recentSteps =
                Arrays.asList(
                        StepRecord.createWithTimestamp(guardianId, StepCount.of(1000), Timestamp.of(date.minusDays(2).atTime(10, 0))),
                        StepRecord.createWithTimestamp(guardianId, StepCount.of(1200), Timestamp.of(date.minusDays(1).atTime(10, 0))),
                        StepRecord.createWithTimestamp(guardianId, StepCount.of(1500), Timestamp.of(date.atTime(10, 0))) // Normal progression
                        );

        when(stepRepository.findByGuardianIdAndDateRange(guardianId, date.minusDays(7), date))
                .thenReturn(recentSteps);

        // When
        boolean result = stepValidationService.hasStepCountSpike(guardianId, date);

        // Then
        assertFalse(result);
        verify(stepRepository, times(1))
                .findByGuardianIdAndDateRange(guardianId, date.minusDays(7), date);
    }

    @Test
    @DisplayName("Should validate step submission rate")
    void shouldValidateStepSubmissionRate() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        Timestamp timestamp = Timestamp.of(LocalDateTime.now());

        when(stepRepository.countSubmissionsInLastHour(guardianId, timestamp.value())).thenReturn(10);

        // When
        boolean result = stepValidationService.isWithinSubmissionRateLimit(guardianId, timestamp.value());

        // Then
        assertTrue(result);
        verify(stepRepository, times(1)).countSubmissionsInLastHour(guardianId, timestamp.value());
    }

    @Test
    @DisplayName("Should reject when submission rate limit exceeded")
    void shouldRejectWhenSubmissionRateLimitExceeded() {
        // Given
        GuardianId guardianId = GuardianId.of(1L);
        Timestamp timestamp = Timestamp.of(LocalDateTime.now());

        when(stepRepository.countSubmissionsInLastHour(guardianId, timestamp.value()))
                .thenReturn(120); // Exceeds limit

        // When
        boolean result = stepValidationService.isWithinSubmissionRateLimit(guardianId, timestamp.value());

        // Then
        assertFalse(result);
        verify(stepRepository, times(1)).countSubmissionsInLastHour(guardianId, timestamp.value());
    }

    @Test
    @DisplayName("Should validate step data integrity")
    void shouldValidateStepDataIntegrity() {
        // Given
        StepRecord stepRecord = StepRecord.createWithTimestamp(GuardianId.of(1L), StepCount.of(5000), Timestamp.of(LocalDateTime.now()));

        // When
        boolean result = stepValidationService.hasValidDataIntegrity(stepRecord);

        // Then
        assertTrue(result);
    }

    @Test
    @DisplayName("Should reject step data with invalid integrity")
    void shouldRejectStepDataWithInvalidIntegrity() {
        // Given
        StepRecord stepRecord =
                StepRecord.createWithTimestamp(null, StepCount.of(5000), Timestamp.of(LocalDateTime.now())); // Invalid guardian ID

        // When
        boolean result = stepValidationService.hasValidDataIntegrity(stepRecord);

        // Then
        assertFalse(result);
    }
}
